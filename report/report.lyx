#LyX 1.4.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\float_placement H
\paperfontsize default
\spacing single
\papersize a4paper
\use_geometry true
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
date{}
\end_layout

\end_inset


\series bold
\size giant
PEJS
\series default
\size default

\newline
Python Executed in JavaScript
\end_layout

\begin_layout Standard
\align center

\series bold
\size giant
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
setcounter{page}{-1}
\end_layout

\begin_layout Standard


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename logo.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement b
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Jesper Jakobsen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Rune Fogh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ubbe Welling
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20052904
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20052251
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20052275
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
u052904@daimi.au.dk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
rfogh@daimi.au.dk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ubbe@daimi.au.dk
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\begin_inset LatexCommand \tableofcontents{}

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section

\series bold
Introduction
\end_layout

\begin_layout Standard
This report is the final handin in the course 
\begin_inset Quotes sld
\end_inset

Design of Virtual Machines for Object Oriented Languages
\begin_inset Quotes srd
\end_inset

 taught at Department of Computer Science at Aarhus University.
 The course has been taught by Lars Bak and Kasper Lund, assisted by teaching
 assistant Mathias Schwarz.
\end_layout

\begin_layout Standard
It describes the design and implementation of a virtual machine for for
 the programming language Python done in JavaScript.
 The purpose of this report is to convey a description of our work process,
 the status of the project and the results obtained so far.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Virtual machines for JavaScript exist in all modern browsers and since browsers
 exist on most operating systems JavaScript is practicaly platform independent.
 So if we could make a virtual machine in JavaScript that takes a python
 program we can make python platform independent.
\end_layout

\begin_layout Standard
Further the groving use of JavaScript on the internet has pushed the need
 for an efficient virtual machine, the work by Google
\begin_inset Foot
status collapsed

\begin_layout Standard
http://code.google.com/p/v8
\end_layout

\end_inset

 and Mozilla
\begin_inset Foot
status collapsed

\begin_layout Standard
http://www.mozilla.org/js/spidermonkey
\end_layout

\end_inset

 has made it interesting to investigate if it is viable to build a virtual
 machine on top of a JavaScript virtual machinal which is known for having
 poor performance.
\end_layout

\begin_layout Section
Goals
\end_layout

\begin_layout Standard
Here we briefly state our initial goals and milestones for the project.
\end_layout

\begin_layout Standard
Our main goal was:
\newline

\end_layout

\begin_layout Standard

\series bold
In JavaScript, implement a VM for a subset of the Python language.
\series default

\newline

\end_layout

\begin_layout Standard
This was broken down into smaller goals, or milestones, as follows:
\end_layout

\begin_layout Enumerate
Get simple interpreter operating on a stack up and running
\end_layout

\begin_layout Enumerate
Implement basic constructs: Jumps and loops
\end_layout

\begin_layout Enumerate
Decide on object representation and heap layout
\end_layout

\begin_layout Enumerate
Implement classes and objects
\end_layout

\begin_layout Enumerate
Implement simple garbage collector if necessary
\end_layout

\begin_layout Enumerate
Handle calls to Python library somehow
\end_layout

\begin_layout Enumerate
Do performance evaluation and improvement
\end_layout

\begin_layout Standard
As we only had around 8 weeks for the project, we decided that points 1-4
 were required while 5 and 6 could be omitted if necessary.
 Performance evaluation was naturally a must, and improvement was also something
 we definitely aimed at working with.
\end_layout

\begin_layout Section
Description
\end_layout

\begin_layout Subsection
Overview
\begin_inset LatexCommand \label{sub:Overview}

\end_inset


\end_layout

\begin_layout Standard
The project consists of two parts, compiling the python code to python opcodes
 in a format we can interpret, and interpreting the opcodes in JavaScript.
 The focus of this course is to make a VM so naturally we focus on the interpret
ation part rather than the compilation part.
 In order to save time we use the python compiler to get the opcodes and
 other information we need at print it as needed.
\end_layout

\begin_layout Standard
The intermediary opcode format is formed as a JavaScript object we call
 codeObject.
 This is illustrated by figure 
\begin_inset LatexCommand \ref{overview}

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename overview.eps
	lyxscale 50
	scale 30

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{overview}

\end_inset

Overview of PEJS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We compile the python file with tools/compile.py which outputs a js file
 with the code object.
 To illustrate this here is an example of a py file and the corresponding
 codeObject.
\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
class Greet:
\end_layout

\begin_layout LyX-Code
  def printGreeting(self):
\end_layout

\begin_layout LyX-Code
    print "Hello world!"
\end_layout

\begin_layout LyX-Code
Greet().printGreeting()
\end_layout

\begin_layout Caption
Helloworld.py
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
//This file was automatically created with compiler.py
\newline

\newline

\end_layout

\begin_layout LyX-Code
var Helloworld = {
\end_layout

\begin_layout LyX-Code
  co_name: "?",
\end_layout

\begin_layout LyX-Code
  co_argcount: 0,
\end_layout

\begin_layout LyX-Code
  co_nlocals: 0,
\end_layout

\begin_layout LyX-Code
  co_varnames: ["Greet"],
\end_layout

\begin_layout LyX-Code
  co_code: [100,0,0,102,0,0,100,0,1,132,0,0,131,0,0,89,90,0,0,101,0,0,
\end_layout

\begin_layout LyX-Code
            131,0,0,105,0,1,131,0,0,1,100,0,2,83],
\end_layout

\begin_layout LyX-Code
  co_consts: ["Greet", "CODEOBJ: Helloworld_Greet", "None"],
\end_layout

\begin_layout LyX-Code
  co_names: ["Greet", "printGreeting"],
\end_layout

\begin_layout LyX-Code
  co_locals: [],
\end_layout

\begin_layout LyX-Code
  toString: function() { return "CodeObject:Helloworld"} 
\end_layout

\begin_layout LyX-Code
};
\newline

\newline

\end_layout

\begin_layout LyX-Code
var Helloworld_Greet = {
\end_layout

\begin_layout LyX-Code
  co_name: "Greet",
\end_layout

\begin_layout LyX-Code
  co_argcount: 0,
\end_layout

\begin_layout LyX-Code
  co_nlocals: 0,
\end_layout

\begin_layout LyX-Code
  co_varnames: [],
\end_layout

\begin_layout LyX-Code
  co_code: [116,0,0,90,0,1,100,0,1,132,0,0,90,0,2,82,83],
\end_layout

\begin_layout LyX-Code
  co_consts: ["None", "CODEOBJ: Helloworld_Greet_printGreeting"],
\end_layout

\begin_layout LyX-Code
  co_names: ["__name__", "__module__", "printGreeting"],
\end_layout

\begin_layout LyX-Code
  co_locals: [],
\end_layout

\begin_layout LyX-Code
  toString: function() { return "CodeObject:Helloworld_Greet"} 
\end_layout

\begin_layout LyX-Code
};
\newline

\newline

\end_layout

\begin_layout LyX-Code
var Helloworld_Greet_printGreeting = {
\end_layout

\begin_layout LyX-Code
  co_name: "printGreeting",
\end_layout

\begin_layout LyX-Code
  co_argcount: 1,
\end_layout

\begin_layout LyX-Code
  co_nlocals: 1,
\end_layout

\begin_layout LyX-Code
  co_varnames: ["self"],
\end_layout

\begin_layout LyX-Code
  co_code: [100,0,1,71,72,100,0,0,83],
\end_layout

\begin_layout LyX-Code
  co_consts: ["None", "Hello world!"],
\end_layout

\begin_layout LyX-Code
  co_names: [],
\end_layout

\begin_layout LyX-Code
  co_locals: [],
\end_layout

\begin_layout LyX-Code
  toString: function() { return "CodeObject:Helloworld_Greet_printGreeting"}
 
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{Helloworld.js codeObject}

\end_inset

Helloworld.js
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to run the python code in a browser you need to import the interpreter(
src/interpreter.js), the standart library(src/lib/stdlib.py) and the codeObject
 file, in this example Helloworld.js.
 In a html file you then need to execute the interpret method with the name
 of the file as a string.
\end_layout

\begin_layout LyX-Code
(new PEJS()).interpret("Helloworld");
\end_layout

\begin_layout Standard
This implies that the creator of the website needs a python compiler to
 generate codeObjects but not the users of the website.
 It is possible to make a Python compiler in JavaScript which could be imported
 in the html file.
 That would allow Python directly embedded in the html.
 This is not in the scope of the course and therefore not implemented.
 See appendix 
\begin_inset LatexCommand \ref{sec:How-to-run}

\end_inset

 for more details on running PEJS.
\end_layout

\begin_layout Subsection
Compiler
\end_layout

\begin_layout Standard
As our main focus of this project has been implementing a VM, the compiler
 has been made quick and dirty in Python.
 The main purpose of the compiler is to compile Python code to Python byte
 code and present it in a JavaScript format.
 We wanted to make our VM run Python byte code, so in that respect, the
 format was settled, but at the same time, we wanted to experiment with
 the way we represented the byte code in JavaScript.
\end_layout

\begin_layout Standard
In practice, the compiler compiles .py files to .pyc and decompiles them into
 Python objects representing code objects, from which our code objects are
 generated.
\end_layout

\begin_layout Subsection
Code objects
\end_layout

\begin_layout Standard
Python has a notion of code objects as containers of code.
 We have code objects for classes, functions, methods and the main program,
 in Python known as a module.
 The compiler resolves, whether a code object is for instantiating a class
 or is a function and calls the proper byte codes afterwards.
 Besides containing the actual byte codes, code objects also contain several
 properties resolved during compilation.
 At first in the project, we represented all properties from Python code
 objects in our JavaScript representation, but since we haven't seen any
 use for some of them so far, we decided to remove the unused properties.
 The properties being used are described in table 
\begin_inset LatexCommand \ref{tab:code-objects}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Property
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Explanation
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Name of the class or function
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_argcount
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Number of arguments expected by function
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_nlocals
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Number of local variables used in the code object
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_varnames
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Array of local variable names
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Array of byte codes, represented as integers
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_consts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Array of constants such as string, integers and other code objects
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_names
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Array of names of functions, classes and/or properties
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
co_locals
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Empty Array used to store local variable values
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:code-objects}

\end_inset

Our Javascript representation of Python code objects.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The byte codes have been represented in two different ways during the project.
 At first, we represented each byte code as an Array in order to carry a
 lot of debugging information along with the byte codes.
 Later in the project, when we settled on the basic structure and most of
 our VM worked as in the current state, we changed this to a more effective
 representation, where each byte code is one or three entries in an array
 instead of one an entire array by itself.
 The optimization benefits of this change is discussed later in the report.
\end_layout

\begin_layout Subsection
Interpreter
\end_layout

\begin_layout Standard
The interpreter is designed as a simple fetch-decode-execute cycle.
 The main structure of the interpreter is a while-loop with a switch-case
 that executes code objects.
 As shown the example in figure 
\begin_inset LatexCommand \ref{fetch-decode-execute}

\end_inset

, the interpreter maintains a program counter (
\family typewriter
pc
\family default
), which is an array index in the code objects 
\family typewriter
co_code
\family default
 property.
 The byte code indexed by 
\family typewriter
pc
\family default
 is read out to the 
\family typewriter
bytecode
\family default
 variable.
 In Python, all byte codes of value 90 or larger has an argument as well,
 so if this is the case, the argument is read out as well, and 
\family typewriter
pc
\family default
 incremented correspondingly.
 Then 
\family typewriter
bytecode
\family default
 is switched to get the correct case, and the contents of the case is executed.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename interpreter.eps
	lyxscale 50
	scale 30

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fetch-decode-execute}

\end_inset

Fetch-decode-execute cycle for byte code 
\family typewriter
116
\family default
, 
\family typewriter
LOAD_GLOBAL
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The fetch-decode-execute cycle is initiated when a new function is called
 and terminates with the byte code 
\family typewriter
RETURN_VALUE
\family default
 or when an exception is raised without being catched in the current cycle
 (At the moment, exceptions is not fully supported.
 See more in section 
\begin_inset LatexCommand \ref{current status - exceptions}

\end_inset

).
\end_layout

\begin_layout Standard
At the moment, we pay the full penalty of the switch-case, but we have some
 suggestions on how to improve performance of the cycle.
 These suggestions can be found in section 
\begin_inset LatexCommand \ref{future work}

\end_inset

.
\end_layout

\begin_layout Subsection
Architecture
\end_layout

\begin_layout Standard
The virtual machine is structured as shown in figure 
\begin_inset LatexCommand \ref{static-structure}

\end_inset

.
 The interpreter has been implemented on the 
\family typewriter
prototype
\family default
 object of the 
\family typewriter
PEJS
\family default
 constructor.
 Two constructors are also implemented on the 
\family typewriter
prototype
\family default
 object, namely 
\family typewriter
Stack
\family default
 and 
\family typewriter
Globals
\family default
, which are described in more details in section 
\begin_inset LatexCommand \ref{description_memory-model}

\end_inset

.
 Furthermore, the 
\family typewriter
types
\family default
 
\begin_inset Quotes sld
\end_inset

namespace
\begin_inset Quotes srd
\end_inset

 (implemented as an object) on the 
\family typewriter
prototype
\family default
 object, contains the constructors for all built-in types.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename static_structure.eps
	lyxscale 50
	scale 30

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{static-structure}

\end_inset

Static structure of 
\family typewriter
interpret.js
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Memory model
\begin_inset LatexCommand \label{description_memory-model}

\end_inset


\end_layout

\begin_layout Subsubsection
Stack
\begin_inset LatexCommand \label{description_memory-model_Stack}

\end_inset


\end_layout

\begin_layout Standard
We have implemented the stack as a JavaScript object with an array containing
 containing the elements of the stack.
 The stack object also has a bottom pointer(BP) and a stack pointer(SP)
 pointing to the top and bottom of the current stackframe respectively.
 When we call and return from functions we call the removeFrame and newFrame
 methods, these modify the stack as shown in figure 
\begin_inset LatexCommand \ref{stack}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename stack.eps
	lyxscale 30
	scale 24

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{stack}

\end_inset

Stack example
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On removeFrame we syncronize the localvariables with the arguments on the
 stack and sets TOS to the return value.
 From figure 
\begin_inset LatexCommand \ref{stack}

\end_inset

 it shows that we don't delete things from the stack again, we just overwrite
 the contents when pushing data onto the stack.
 It could be advantageous to delete data over the SP when returning from
 a method this would allow the JavaScript VM to garbage collect the used
 data.
\end_layout

\begin_layout Subsubsection
Local and global variables
\end_layout

\begin_layout Standard
Local variables are stored in the respective code object's 
\family typewriter
co_varnames
\family default
 and 
\family typewriter
co_locals
\family default
.
 The compiler resolves most of the names and adds them to 
\family typewriter
co_varnames
\family default
, and on runtime, the corresponding values are stored at the same index
 in 
\family typewriter
co_locals
\family default
.
 When a function is called, a new stack frame is created, with space allocated
 for the local variables as described in section 
\begin_inset LatexCommand \ref{description_memory-model_Stack}

\end_inset

.
\end_layout

\begin_layout Standard
Global variables are stored in the 
\family typewriter
Globals
\family default
 object, which consists of an array of arrays and some convenience methods.
 The first inner array is a special array reserved for new global variables,
 while the other inner arrays are added on runtime as direct references
 to the outermost code objects's 
\family typewriter
co_varnames
\family default
 and 
\family typewriter
co_locals
\family default
.
 The reason for this odd construction is the Python compilers lacking ability
 to resolve whether a variable is local or global at compile-time, so the
 best working solution we have come up with so far is the one just outlined.
\end_layout

\begin_layout Standard
Lookup of unresolved variables, implemented as the byte code 
\family typewriter
LOAD_NAME
\family default
, is done by first looking through 
\family typewriter
co_varnames 
\family default
and secondly through the global variables.
 Each of these lookups takes time linear in the number of local and global
 variables, respectively.
\end_layout

\begin_layout Subsubsection
Objects
\end_layout

\begin_layout Standard
Python does, not surprisingly, use classes, objects and functions.
 We have choosen to implement these elements as objects.
 The properties and relations of these is given in figure 
\begin_inset LatexCommand \ref{python objects}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename types.eps
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{python objects}

\end_inset

Representation of Python objecs and classes
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tuples, lists and dictionaries
\begin_inset LatexCommand \label{Tuples,-lists-and}

\end_inset


\end_layout

\begin_layout Standard
Python has three basic collection types, namely tuples, lists and dictionaries.
 Lists are mutable collections of values, corresponding to JavaScript arrays,
 while tuples are immutable lists.
 Dictionaries are a mutable collection of key-value pairs, similar to a
 Javascript object.
 The obvious approach was therefore to represent dictionaries as JavaScript
 object and lists and tuples as JavaScript arrays.
 The three collection types are represented as PyTuple, PyList and PyDict,
 which each has a 
\family typewriter
store
\family default
 property, that contain an array or an object, respectively.
\end_layout

\begin_layout Standard
Methods on lists and dictionaries are implemented in JavaScript only, which
 was chosen because it was the simplest approach at the time, although they
 possibly to a greater extent could be part of the standard library.
 iew of the directory structure and content and purpose of the various files
 in the project.
\end_layout

\begin_layout Subsection
Library
\end_layout

\begin_layout Standard
We have started an implementation of the Python library in order to support
 some of the most basic functionality.
 While we have not implemented much, the idea was just as much to see if
 we could get a library working at all.
\end_layout

\begin_layout Standard
The library is primaily implemented in Python which seemed most elegant.
 This includes We still had to establish some way of calling into JavaScript
 which is done as in the following example: 
\end_layout

\begin_layout LyX-Code
exec "new PEJS.prototype.types.PyTuple("+list+");" in "JavaScript", "result"
 
\end_layout

\begin_layout LyX-Code
return result
\end_layout

\begin_layout Standard
In the EXEC_STMT case in the interpreter (case 85) we test if the second
 parameter is "JavaScript", in which case we evaluate the given statement
 and store the result in the named variable, which is then accessible in
 Python.
 This clearly enables arbitrary extensions of the library, as it is always
 possible to bail out to JavaScript implementation when Python is not sufficient.
 It is also easy to add new implementation.
 One just writes the code in the right place, and everything works automatically.
\end_layout

\begin_layout Standard
The library .py-files are translated and the generated JavaScript file is
 then referenced in the HTML, just like the interpreter itself.
 Writing "import time" then works exactly as it should.
 The standard library is imported automatically, as it should be.
\end_layout

\begin_layout Subsection
Test framework
\end_layout

\begin_layout Standard
During our development of our VM, it became obvious that we needed to establish
 some kind of systematic testing in order to make sure that we didn't break
 existing functionality when refactoring and adding new features.
 Thus, we set up a few scripts to automatically translate tests written
 in Python into our JavaScript representation.
 We could then benefit from the fact that our VM runs in a browser in that
 we pretty quickly had a nice HTML interface (test/test.html) working in
 which we could run all tests and also see detailed runs of single tests.
 We used this for running benchmarks as well.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename testscreenshot.png
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Caption
Screenshot of full test.
 Each test can be clicked in order to run a trace of that particular case.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename testscreenshot2.png
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Caption
Screenshot of single test.
 Each blue headline indicates that control has been transferred to another
 code object.
 The stack grows to the right.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to the HTML interface, we set up scripts for running the tests
 and benchmarks in the console using Google's V8 to run our VM, as well
 as directly in Python.
\end_layout

\begin_layout Standard
The setup was fairly slick so tests could be added just by adding the file
 containing the test code and running a single script (tools/createTest.py).
 
\end_layout

\begin_layout Standard
After having established this small test framework, our development was
 almost purely testdriven.
 This made development somewhat more relaxed as the tests provided confidence
 that a given modification actually worked.
 The tests also encouraged us to a more experimental approach to possible
 modifications - making a change and testing it was often much quicker than
 figuring out if it would work in every situation.
 Finally it was also quicker for us to correct errors, as the test overview
 and especially the single test trace made it easy to identify problems.
\end_layout

\begin_layout Section
Current status
\end_layout

\begin_layout Subsection
Supported language
\end_layout

\begin_layout Standard
In this section we describe roughly what parts of the Python language our
 VM supports.
 
\end_layout

\begin_layout Standard
We decided on implementing Python 2.4.3, as that was the version installed
 on the department's machines.
\end_layout

\begin_layout Standard
Everything described here is assured to some degree with testcases, but
 it should be noted that there is lots of room for more thorough testing.
 This also means that our claims of supported features below only holds
 to the extent ensured by our tests.
 Examples of unsupported features can be seen in test/unsupported
\end_layout

\begin_layout Standard
It should also be mentioned that we have no negative testcases and have
 not attempted to catch illegal programs in our implementation.
 Thus, running an illegal program will cause undefined behavior.
\end_layout

\begin_layout Subsubsection
Basic arithmetics
\end_layout

\begin_layout Standard
Basic arithmetic operations were fairly easily implemented, as we just used
 the corresponding JavaScript operators.
 This also means that the semantics have not been ensured any further than
 what is specified in the test cases.
 Longs are not supported, but floats are.
 The implementation doesn't quite match Python's apparent intention of making
 everything objects, which would imply that even the basic arithmetic operators
 should be implemented as functions or methods.
 
\end_layout

\begin_layout Subsubsection
Basic constructs
\end_layout

\begin_layout Standard
Conditionals and loops are supported fully, and especially loops have been
 tested reasonably well.
 We support both the 
\family typewriter
range
\family default
 and 
\family typewriter
the xrange 
\family default
constructs which are typically used in 
\family typewriter
for
\family default
-loops.
 The semantics are correct, as 
\family typewriter
range
\family default
 actually produces a list while 
\family typewriter
xrange
\family default
 is implemented in a more space efficient manner which generates each index
 lazily.
 Both are implemented in the library, purely in Python.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Functions/methods
\end_layout

\begin_layout Standard
We implemented functions before classes, in order to be ready to implement
 methods when introducing classes.
 Functions and methods are fully supported, including nesting and recursion.
 Keyword arguments and default arguments are working, and so is optional
 parameters.
 That is, both * and ** work, and can be used both when defining functions
 and when calling them.
\end_layout

\begin_layout Subsubsection
Classes and objects
\end_layout

\begin_layout Standard
Classes and objects are of course supported.
 We don't fully support the correct semantics when dynamically injecting
 fields on classes.
 In Python, update or addition of a field on a class is automatically pushed
 to all instances of the class, overwriting or marking dirty every instance's
 value for that field.
 We have not implemented this behavior, as that would require every class
 to hold references to all instances of it.
 This is of course possible, but we decided not to implement it partly because
 we discovered the issue shortly before deadline and partly because it would
 not be very elegant.
\end_layout

\begin_layout Standard
Inheritance was fairly easy to add on top of the basic class/object implementati
on, as Python's inheritance rules are reasonably simple.
 They simply state that the ordered list of base classes should be traversed
 in order and the first field/method with matching name should be chosen.
 This is working as it should which is ensured by a couple of tests.
\end_layout

\begin_layout Standard
It should be noted that we have by no means examined every corner of the
 language, and therefore there probably are subtle (and less subtle) features
 we don't handle.
\end_layout

\begin_layout Subsubsection
Lists, tuples and dictionaries
\end_layout

\begin_layout Standard
These are the basic data structures in Python.
 They have all been implemented directly in JavaScript since Python has
 no arrays on which to build.
 For more information see section 
\begin_inset LatexCommand \ref{Tuples,-lists-and}

\end_inset

.
\end_layout

\begin_layout Subsubsection
Iterators
\end_layout

\begin_layout Standard
In Python, any object may be 
\emph on
iterable, 
\emph default
meaning that it can return an iterator that can enumerate the object in
 some sensible way, using the methods next() and getItem(...).
 We've implemented the iterator for lists and tuples which works as it should.
 In principle it also works for general objects, where the object itself
 is responsible for implementing the actual iterator somehow.
 This has not been tested though.
\end_layout

\begin_layout Subsubsection
Exceptions
\begin_inset LatexCommand \label{current status - exceptions}

\end_inset


\end_layout

\begin_layout Standard
We have very basic support for exceptions.
 A special case handles the StopIteration exception which is necessary for
 iterators to work.
 Aside from that, using the 
\family typewriter
raise 
\family default
keyword with no argument behaves correctly together with 
\family typewriter
try
\family default
 and 
\family typewriter
except.
 
\family default
It should also be possible to give an argument to 
\family typewriter
raise
\family default
, which will simply be ignored, but this has not been tested.
\end_layout

\begin_layout Subsection
Optimizations
\end_layout

\begin_layout Subsubsection
Jumps
\end_layout

\begin_layout Standard
A jump bytecode has an argument telling where to jump to.
 In the first version of our codeObject the co_code array, which contains
 the opcodes and arguments, contained each instruction as a sub-array.
 This meant that we could not jump directly to that index since we had obscured
 the instruction array.
 Instead we needed to search through the each instruction array to se if
 this had the offset we were looking for.
 This original approach had the advantage that we could have the instruction
 name and other information available, this helped us understand the programs,
 but we wanted to make it fast so we optimized it.
\end_layout

\begin_layout Standard
The approach was to create a single array with the opcodes and arguments
 an example of the co_code array can be seen in figure 
\begin_inset LatexCommand \ref{Helloworld.js codeObject}

\end_inset

.
 This allowed us to jump directly to the instruction given by the argument
 to the jump bytecode.
 We were expecting a big improvement in performance as jumping directly
 must be way faster than looking through an array, in practice we only saw
 a slight increase in performance based on the bencmarks in the test suite.
 From about 3200ms to 3100ms we think thats due to the structure of the
 tests where we don't need to jump very far and therefore don't need to
 scan for the right offset very long.
\end_layout

\begin_layout Subsubsection
Refactoring
\end_layout

\begin_layout Standard
When we started the implenentation many of the elements from figure 
\begin_inset LatexCommand \ref{static-structure}

\end_inset

 was implemented as globals.
 This is obviously a poor choice and we desided to refactor and introduce
 the structure we have now.
 We expected to see a performance decrease since lookup of the elements
 would be more indirect, it turns out that the refactoring had an huge possitive
 impact on performance.
 We went from times around 3100ms to 1100ms to execute our benchmarks, we
 have discovered that this is because globals takes a very long time to
 resolve.
 
\end_layout

\begin_layout Subsection
Benchmarks
\end_layout

\begin_layout Subsection
Compare with goals
\end_layout

\begin_layout Section
Future work
\begin_inset LatexCommand \label{future work}

\end_inset


\end_layout

\begin_layout Subsection
Optimizations
\end_layout

\begin_layout Subsubsection
JIT Compilation
\end_layout

\begin_layout Standard
An interesting optimization would be adding a kind of JIT compilation.
 In the interpreter switch, it is clearly possible just generating and saving
 JavaScript code as a string instead of actually executing it.
 This way, the Python bytecodes could be parsed, resulting in an equivalent
 JavaScript program which could then be executed without the interpreting
 overhead between each operation.
 This is an improvement in itself, but it would probably result in an additional
 performance gain when running on V8, which would be able to compile the
 entire program in one chunk.
 Generating code in this way would also enable us to do peephole optimization
 on our generated code, though it may be somewhat heavy to parse and modify
 a large program string.
 
\end_layout

\begin_layout Standard
The obstructing complication is jumps.
 When generating the JavaScript code, it seems obvious to use gotos and
 labels whenever we encounter Python bytecodes that jump.
 The only problem is that JavaScript doesn't have have labels and gotos
 in the normal sense, which at first seems a complete showstopper for this
 approach.
 
\end_layout

\begin_layout Standard
A possible workaround would be to slice the entire program, dividing it
 into functions in every place a label is needed.
 A goto can then be done as a call to the correct function, and the semantics
 of the sequential program could be maintained by letting each function
 end by calling the next.
 This would probably generate an unreasonably high call stack, but this
 could be avoided by just calling the functions in sequence.
 Unfortunately, every jump would still cause a nested function call.
 That could be avoided by letting functions return a value indicating what
 they want to be called next, but then we've more or less introduced the
 interpreting overhead again which makes it all seem futile.
 
\end_layout

\begin_layout Standard
An option would be to just generate code between jumps and let jumps be
 handled in the interpreter.
 It is not clear whether this would yield any significant performance improvemen
t, and unfortunately we didn't have the time for implementing it.
\end_layout

\begin_layout Subsubsection
Stack as array
\end_layout

\begin_layout Subsubsection
Switch-case as array
\end_layout

\begin_layout Subsubsection
Optimizations on byte code order and format
\end_layout

\begin_layout Standard
Throughout the project, we have relied on the order, in which the Python
 compiler output byte codes.
 In some cases, the way we handle byte codes does not correspond to the
 optimal order, in which elements could be placed on the stack.
 In the example shown as algorithm 
\begin_inset LatexCommand \ref{alg:bytecodeorder}

\end_inset

, three elements are placed on stack in the order shown in figure 
\begin_inset LatexCommand \ref{fig:bytecodeorder}

\end_inset

.
 The present stack order makes it necessary to use two named local variables,
 instead of supplying the arguments unnamed to the JavaScript 
\family typewriter
slice
\family default
 method as shown.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
//Present byte code order:
\end_layout

\begin_layout LyX-Code
case 33: //SLICE+3
\end_layout

\begin_layout LyX-Code
  var end = stack.pop();
\end_layout

\begin_layout LyX-Code
  var start = stack.pop();
\end_layout

\begin_layout LyX-Code
  stack.push(new this.types.PyList(stack.pop().store.slice(start,end)));
\end_layout

\begin_layout LyX-Code
  break;
\newline

\newline
//Optimized byte code order:
\end_layout

\begin_layout LyX-Code
case 33: //SLICE+3
\end_layout

\begin_layout LyX-Code
  stack.push(new this.types.PyList(stack.pop().store.slice(stack.pop(),
\end_layout

\begin_layout LyX-Code
                                                           stack.pop())));
\end_layout

\begin_layout LyX-Code
  break;
\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{alg:bytecodeorder}

\end_inset

Examples of present and optimized byte code order usage.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bytecodeorder.eps
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:bytecodeorder}

\end_inset

Stack in present an optimized state before a SLICE+3 byte code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As JavaScript being a high-level language, the impact of this suggested
 optimization is hard to predict, as a JavaScript compiler could optimize
 the present implementation to be as performant as the suggested, optimized
 implementation.
\end_layout

\begin_layout Subsubsection
Library snapshot
\end_layout

\begin_layout Standard
Upon startup of an execution we interpret the standard library every time.
 Since the library is pretty static it could be advantageous to create a
 snapshot of the library that could just be executed everytime instead of
 interpretted.
 This would decrease load time, especially as the library increases.
 In the current state the library is not that big so the penalty is not
 that big.
\end_layout

\begin_layout Subsection
Python compiler
\end_layout

\begin_layout Standard
Implementing a python compiler in JavaScript that outputs the codeObjects
 we need, would allow us to have python embedded in a html document.
 There is no technical obsacles in the way of doing this, and if PEJS is
 to have much use in the real world this would definately be needed.
 We have focused on the VM since that is what this course is about, but
 it could be a nice sparetime project.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Library extension (DOM extension)
\end_layout

\begin_layout Subsection
Debugger
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
\start_of_appendix
Directory structure
\end_layout

\begin_layout Standard
For convenience we provide an overview of the directory structure and content
 and purpose of the various files in the project.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code

\color red
src/ 
\end_layout

\begin_layout LyX-Code

\color red
  lib/
\color inherit
                   
\color black
Library functions, implemented in Python.
\end_layout

\begin_layout LyX-Code
    
\color blue
stdlib.py            
\color black
Python standard library, imported by default.
\end_layout

\begin_layout LyX-Code

\color blue
    string.py            
\color black
Python string library.
\end_layout

\begin_layout LyX-Code

\color blue
    time.py              
\color black
Python time library.
\end_layout

\begin_layout LyX-Code

\color blue
  interpreter.js    
\color inherit
     All of the actual virtual machine.
\end_layout

\begin_layout LyX-Code

\color red
test/ 
\color inherit
                   Tests and benchmarks.
 Note that benchmarks look like
\end_layout

\begin_layout LyX-Code
                         tests, but don't actually test anything.
\end_layout

\begin_layout LyX-Code
 
\color red
 unsupported/
\color inherit
           Tests and benchmarks not currently supported.
\end_layout

\begin_layout LyX-Code

\series bold
    
\series default
\color blue
<test or benchmark>.py
\end_layout

\begin_layout LyX-Code
  
\color blue
test.html  
\color inherit
            Open this to run tests and see results in a browser 
\end_layout

\begin_layout LyX-Code
                         (requires tools/createTest.py to be run first).
\end_layout

\begin_layout LyX-Code

\color blue
  testBenchmark.html   
\color inherit
  Run benchmarks in browser, output formatted for
\end_layout

\begin_layout LyX-Code
                         copying to spiderlog.txt (accessible from test.html).
\end_layout

\begin_layout LyX-Code

\series bold
  
\series default
\color blue
testSingle.html   
\color inherit
     Run single test and show execution and stack trace 
\end_layout

\begin_layout LyX-Code
                         (should be accessed from test.html).
\end_layout

\begin_layout LyX-Code
  
\color blue
<test or benchmark>.py
\color inherit
 Actual tests and benchmarks.
\end_layout

\begin_layout LyX-Code

\color red
tools/  
\color inherit
                 Utility scripts.
 Should be invoked from root folder
\end_layout

\begin_layout LyX-Code
                         (e.g.
 ./tools/createTest.py).
\end_layout

\begin_layout LyX-Code
  
\color blue
prepareStandalone.js
\end_layout

\begin_layout LyX-Code

\color blue
  prepareStandaloneBenchmark.js
\end_layout

\begin_layout LyX-Code
  
\color blue
compiler.py 
\color inherit
           Uses the Python compiler to translate from Python
\end_layout

\begin_layout LyX-Code
                         source code to JavaScript containing Python bytecodes.
\end_layout

\begin_layout LyX-Code

\series bold
  
\series default
\color blue
createTest.py  
\color inherit
        Translates all tests and benchmarks.
 
\end_layout

\begin_layout LyX-Code
                         Necessary for test.html to work.
\end_layout

\begin_layout LyX-Code

\series bold
 
\series default
\color blue
 benchmarkInV8.sh   
\color inherit
    Performs benchmark in V8 and appends the result 
\end_layout

\begin_layout LyX-Code
                         to v8log.txt.
\end_layout

\begin_layout LyX-Code

\color blue
  cleanup.sh   
\color inherit
          Removes all generated files.
\end_layout

\begin_layout LyX-Code

\series bold
 
\series default
\color blue
 prepareStandalone.sh
\end_layout

\begin_layout LyX-Code

\color blue
  prepareStandaloneBenchmark.sh
\end_layout

\begin_layout LyX-Code
  
\color blue
testInPython.sh  
\color inherit
      Runs tests in Python, outputting results to console.
\end_layout

\begin_layout LyX-Code

\series bold
 
\series default
\color blue
 testInV8.sh   
\color inherit
         Runs tests in V8, outputting results to console.
\end_layout

\begin_layout LyX-Code

\color blue
spiderlog.txt   
\series bold
\color inherit
         
\series default
Benchmark results from Firefox.
\end_layout

\begin_layout LyX-Code

\color blue
v8log.txt  
\series bold
\color inherit
              
\series default
Benchmark results from V8.
\end_layout

\begin_layout Caption
Directory and file structure.
 Unimportant folders and files have been omitted.
\end_layout

\end_inset


\end_layout

\begin_layout Section
How to run
\begin_inset LatexCommand \label{sec:How-to-run}

\end_inset


\end_layout

\end_body
\end_document
